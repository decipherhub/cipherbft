//! Ethereum namespace RPC API implementation.

use std::sync::Arc;

use alloy_consensus::transaction::SignerRecoverable;
use alloy_consensus::{Transaction as TxTrait, TxEnvelope};
use alloy_primitives::{Address, Bytes, B256, U256, U64};
use alloy_rpc_types_eth::{
    transaction::AccessListResult, Block, EIP1186AccountProofResponse, FeeHistory, Filter, Log,
    SyncInfo, SyncStatus as EthSyncStatus, Transaction, TransactionReceipt,
};
use jsonrpsee::core::RpcResult as JsonRpcResult;
use jsonrpsee::proc_macros::rpc;
use jsonrpsee::types::ErrorObjectOwned;
use tracing::{debug, trace, warn};

use crate::config::RpcConfig;
use crate::error::RpcError;
use crate::traits::{BlockNumberOrTag, ExecutionApi, MempoolApi, RpcStorage, SyncStatus};

/// Ethereum namespace RPC trait.
///
/// This trait is auto-generated by jsonrpsee and provides both server and client
/// implementations for the eth_* RPC methods.
#[rpc(server, namespace = "eth")]
pub trait EthRpc {
    /// Returns the chain ID used for signing replay-protected transactions.
    #[method(name = "chainId")]
    async fn chain_id(&self) -> JsonRpcResult<U64>;

    /// Returns the number of most recent block.
    #[method(name = "blockNumber")]
    async fn block_number(&self) -> JsonRpcResult<U64>;

    /// Returns an object with data about the sync status or false if not syncing.
    #[method(name = "syncing")]
    async fn syncing(&self) -> JsonRpcResult<EthSyncStatus>;

    /// Returns the balance of the account at the given address.
    #[method(name = "getBalance")]
    async fn get_balance(&self, address: Address, block: Option<String>) -> JsonRpcResult<U256>;

    /// Returns code at a given address.
    #[method(name = "getCode")]
    async fn get_code(&self, address: Address, block: Option<String>) -> JsonRpcResult<Bytes>;

    /// Returns the value from a storage position at a given address.
    #[method(name = "getStorageAt")]
    async fn get_storage_at(
        &self,
        address: Address,
        slot: U256,
        block: Option<String>,
    ) -> JsonRpcResult<B256>;

    /// Returns the number of transactions sent from an address.
    #[method(name = "getTransactionCount")]
    async fn get_transaction_count(
        &self,
        address: Address,
        block: Option<String>,
    ) -> JsonRpcResult<U64>;

    /// Returns information about a block by hash.
    #[method(name = "getBlockByHash")]
    async fn get_block_by_hash(
        &self,
        hash: B256,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns information about a block by number.
    #[method(name = "getBlockByNumber")]
    async fn get_block_by_number(
        &self,
        block: String,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns the information about a transaction by transaction hash.
    #[method(name = "getTransactionByHash")]
    async fn get_transaction_by_hash(&self, hash: B256) -> JsonRpcResult<Option<Transaction>>;

    /// Returns the receipt of a transaction by transaction hash.
    #[method(name = "getTransactionReceipt")]
    async fn get_transaction_receipt(
        &self,
        hash: B256,
    ) -> JsonRpcResult<Option<TransactionReceipt>>;

    /// Returns an array of all logs matching a given filter object.
    #[method(name = "getLogs")]
    async fn get_logs(&self, filter: Filter) -> JsonRpcResult<Vec<Log>>;

    /// Submits a raw transaction.
    #[method(name = "sendRawTransaction")]
    async fn send_raw_transaction(&self, tx_bytes: Bytes) -> JsonRpcResult<B256>;

    /// Executes a new message call immediately without creating a transaction.
    #[method(name = "call")]
    async fn call(&self, call_request: CallRequest, block: Option<String>) -> JsonRpcResult<Bytes>;

    /// Generates and returns an estimate of how much gas is necessary.
    #[method(name = "estimateGas")]
    async fn estimate_gas(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<U64>;

    /// Returns the current gas price in wei.
    #[method(name = "gasPrice")]
    async fn gas_price(&self) -> JsonRpcResult<U256>;

    /// Returns historical gas information, allowing for better fee estimation.
    ///
    /// Introduced in EIP-1559.
    #[method(name = "feeHistory")]
    async fn fee_history(
        &self,
        block_count: U64,
        newest_block: String,
        reward_percentiles: Option<Vec<f64>>,
    ) -> JsonRpcResult<FeeHistory>;

    /// Returns all pending transactions in the transaction pool.
    ///
    /// This is a non-standard method supported by Reth and Geth.
    /// Returns a flat list of all pending transactions.
    #[method(name = "pendingTransactions")]
    async fn pending_transactions(&self) -> JsonRpcResult<Vec<Transaction>>;

    /// Returns information about an uncle by block hash and uncle index.
    ///
    /// Always returns null for PoS chains (no uncles in CipherBFT).
    #[method(name = "getUncleByBlockHashAndIndex")]
    async fn get_uncle_by_block_hash_and_index(
        &self,
        block_hash: B256,
        index: U64,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns information about an uncle by block number and uncle index.
    ///
    /// Always returns null for PoS chains (no uncles in CipherBFT).
    #[method(name = "getUncleByBlockNumberAndIndex")]
    async fn get_uncle_by_block_number_and_index(
        &self,
        block: String,
        index: U64,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns the number of uncles in a block from a block matching the given hash.
    ///
    /// Always returns 0 for PoS chains (no uncles in CipherBFT).
    #[method(name = "getUncleCountByBlockHash")]
    async fn get_uncle_count_by_block_hash(&self, block_hash: B256) -> JsonRpcResult<U64>;

    /// Returns the number of uncles in a block from a block matching the given number.
    ///
    /// Always returns 0 for PoS chains (no uncles in CipherBFT).
    #[method(name = "getUncleCountByBlockNumber")]
    async fn get_uncle_count_by_block_number(&self, block: String) -> JsonRpcResult<U64>;

    /// Returns the account and storage values including the Merkle proof.
    ///
    /// This method is defined in EIP-1186 and is used for light client verification.
    /// Returns proof data for the account at the given address and storage keys.
    ///
    /// Note: This method returns an error as CipherBFT does not currently expose
    /// state trie access for proof generation.
    #[method(name = "getProof")]
    async fn get_proof(
        &self,
        address: Address,
        storage_keys: Vec<B256>,
        block: Option<String>,
    ) -> JsonRpcResult<EIP1186AccountProofResponse>;

    /// Creates an access list for a transaction.
    ///
    /// This method simulates a transaction and returns the access list that
    /// would be created during execution. The access list contains all addresses
    /// and storage keys that would be accessed.
    ///
    /// Note: This method returns an error as CipherBFT does not currently expose
    /// state access tracking for access list generation.
    #[method(name = "createAccessList")]
    async fn create_access_list(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<AccessListResult>;
}

/// Call request parameters for eth_call and eth_estimateGas.
#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CallRequest {
    /// Sender address.
    pub from: Option<Address>,
    /// Recipient address.
    pub to: Option<Address>,
    /// Gas limit.
    pub gas: Option<U64>,
    /// Gas price.
    pub gas_price: Option<U256>,
    /// Max fee per gas (EIP-1559).
    pub max_fee_per_gas: Option<U256>,
    /// Max priority fee per gas (EIP-1559).
    pub max_priority_fee_per_gas: Option<U256>,
    /// Value to send.
    pub value: Option<U256>,
    /// Transaction data.
    #[serde(alias = "input")]
    pub data: Option<Bytes>,
}

/// Ethereum namespace RPC handler.
pub struct EthApi<S, M, E>
where
    S: RpcStorage,
    M: MempoolApi,
    E: ExecutionApi,
{
    /// Storage interface.
    storage: Arc<S>,
    /// Mempool interface.
    mempool: Arc<M>,
    /// Execution interface.
    executor: Arc<E>,
    /// RPC configuration.
    config: Arc<RpcConfig>,
}

impl<S, M, E> EthApi<S, M, E>
where
    S: RpcStorage,
    M: MempoolApi,
    E: ExecutionApi,
{
    /// Create a new EthApi instance.
    pub fn new(storage: Arc<S>, mempool: Arc<M>, executor: Arc<E>, config: Arc<RpcConfig>) -> Self {
        Self {
            storage,
            mempool,
            executor,
            config,
        }
    }

    /// Parse a block number or tag from a string.
    fn parse_block_number(
        &self,
        block: Option<String>,
    ) -> Result<BlockNumberOrTag, ErrorObjectOwned> {
        match block.as_deref() {
            None | Some("latest") => Ok(BlockNumberOrTag::Latest),
            Some("earliest") => Ok(BlockNumberOrTag::Earliest),
            Some("pending") => Ok(BlockNumberOrTag::Pending),
            Some("safe") => Ok(BlockNumberOrTag::Safe),
            Some("finalized") => Ok(BlockNumberOrTag::Finalized),
            Some(s) => {
                // Parse hex number (0x prefix) or decimal
                let num = if let Some(hex_str) = s.strip_prefix("0x") {
                    u64::from_str_radix(hex_str, 16).map_err(|_| {
                        RpcError::InvalidParams(format!("Invalid block number: {}", s))
                    })?
                } else {
                    s.parse::<u64>().map_err(|_| {
                        RpcError::InvalidParams(format!("Invalid block number: {}", s))
                    })?
                };
                Ok(BlockNumberOrTag::Number(num))
            }
        }
    }

    /// Convert internal RpcError to jsonrpsee ErrorObjectOwned.
    fn to_json_rpc_error(err: RpcError) -> ErrorObjectOwned {
        err.into()
    }

    /// Validate a raw transaction before submission to the mempool.
    ///
    /// This performs:
    /// - RLP decoding validation
    /// - Signature recovery (validates signature is well-formed)
    /// - Chain ID validation (for EIP-155 transactions)
    /// - Basic sanity checks
    fn validate_transaction(&self, tx_bytes: &[u8]) -> Result<(TxEnvelope, Address), RpcError> {
        // Decode the transaction
        let tx: TxEnvelope = alloy_rlp::Decodable::decode(&mut &tx_bytes[..]).map_err(|e| {
            RpcError::InvalidParams(format!("Invalid transaction RLP encoding: {}", e))
        })?;

        // Recover the sender address (this validates the signature)
        let sender = tx.recover_signer().map_err(|e| {
            RpcError::InvalidParams(format!("Invalid transaction signature: {}", e))
        })?;

        // Validate chain ID for EIP-155 transactions
        if let Some(tx_chain_id) = tx.chain_id() {
            if tx_chain_id != self.config.chain_id {
                return Err(RpcError::InvalidParams(format!(
                    "Transaction chain ID {} does not match node chain ID {}",
                    tx_chain_id, self.config.chain_id
                )));
            }
        }

        // Basic sanity checks
        if tx.gas_limit() == 0 {
            return Err(RpcError::InvalidParams(
                "Gas limit cannot be zero".to_string(),
            ));
        }

        // Maximum gas limit sanity check (30 million - typical block gas limit)
        const MAX_GAS_LIMIT: u64 = 30_000_000;
        if tx.gas_limit() > MAX_GAS_LIMIT {
            return Err(RpcError::InvalidParams(format!(
                "Gas limit {} exceeds maximum of {}",
                tx.gas_limit(),
                MAX_GAS_LIMIT
            )));
        }

        debug!(
            "Transaction validated: hash={}, sender={}, gas_limit={}, nonce={}",
            tx.tx_hash(),
            sender,
            tx.gas_limit(),
            tx.nonce()
        );

        Ok((tx, sender))
    }
}

#[async_trait::async_trait]
impl<S, M, E> EthRpcServer for EthApi<S, M, E>
where
    S: RpcStorage + 'static,
    M: MempoolApi + 'static,
    E: ExecutionApi + 'static,
{
    async fn chain_id(&self) -> JsonRpcResult<U64> {
        trace!("eth_chainId");
        Ok(U64::from(self.config.chain_id))
    }

    async fn block_number(&self) -> JsonRpcResult<U64> {
        trace!("eth_blockNumber");
        let number = self
            .storage
            .latest_block_number()
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(number))
    }

    async fn syncing(&self) -> JsonRpcResult<EthSyncStatus> {
        trace!("eth_syncing");
        let status = self
            .storage
            .sync_status()
            .await
            .map_err(Self::to_json_rpc_error)?;

        match status {
            SyncStatus::NotSyncing => Ok(EthSyncStatus::None),
            SyncStatus::Syncing {
                starting_block,
                current_block,
                highest_block,
            } => Ok(EthSyncStatus::Info(Box::new(SyncInfo {
                starting_block: U256::from(starting_block),
                current_block: U256::from(current_block),
                highest_block: U256::from(highest_block),
                // Optional fields
                warp_chunks_amount: None,
                warp_chunks_processed: None,
                stages: None,
            }))),
        }
    }

    async fn get_balance(&self, address: Address, block: Option<String>) -> JsonRpcResult<U256> {
        trace!("eth_getBalance: address={}, block={:?}", address, block);
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_balance(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_code(&self, address: Address, block: Option<String>) -> JsonRpcResult<Bytes> {
        trace!("eth_getCode: address={}, block={:?}", address, block);
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_code(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_storage_at(
        &self,
        address: Address,
        slot: U256,
        block: Option<String>,
    ) -> JsonRpcResult<B256> {
        trace!(
            "eth_getStorageAt: address={}, slot={}, block={:?}",
            address,
            slot,
            block
        );
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_storage_at(address, slot, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_count(
        &self,
        address: Address,
        block: Option<String>,
    ) -> JsonRpcResult<U64> {
        trace!(
            "eth_getTransactionCount: address={}, block={:?}",
            address,
            block
        );
        let block_num = self.parse_block_number(block)?;
        let count = self
            .storage
            .get_transaction_count(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(count))
    }

    async fn get_block_by_hash(
        &self,
        hash: B256,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getBlockByHash: hash={}, full_txs={}",
            hash,
            full_transactions
        );
        self.storage
            .get_block_by_hash(hash, full_transactions)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_block_by_number(
        &self,
        block: String,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getBlockByNumber: block={}, full_txs={}",
            block,
            full_transactions
        );
        let block_num = self.parse_block_number(Some(block))?;
        self.storage
            .get_block_by_number(block_num, full_transactions)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_by_hash(&self, hash: B256) -> JsonRpcResult<Option<Transaction>> {
        trace!("eth_getTransactionByHash: hash={}", hash);

        // First, try to find the transaction in storage (finalized/on-chain)
        match self.storage.get_transaction_by_hash(hash).await {
            Ok(Some(tx)) => return Ok(Some(tx)),
            Ok(None) => {
                // Transaction not in storage, check mempool for pending transactions
                trace!("Transaction {} not in storage, checking mempool", hash);
            }
            Err(e) => return Err(Self::to_json_rpc_error(e)),
        }

        // Fallback: check the mempool for pending transactions
        self.mempool
            .get_transaction_by_hash(hash)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_receipt(
        &self,
        hash: B256,
    ) -> JsonRpcResult<Option<TransactionReceipt>> {
        trace!("eth_getTransactionReceipt: hash={}", hash);
        self.storage
            .get_transaction_receipt(hash)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_logs(&self, filter: Filter) -> JsonRpcResult<Vec<Log>> {
        debug!("eth_getLogs: filter={:?}", filter);

        // Validate block range doesn't exceed max
        if let (Some(from_num), Some(to_num)) = (
            filter
                .block_option
                .get_from_block()
                .and_then(|b| b.as_number()),
            filter
                .block_option
                .get_to_block()
                .and_then(|b| b.as_number()),
        ) {
            let range = to_num.saturating_sub(from_num);
            if range > self.config.max_logs_block_range {
                return Err(RpcError::InvalidParams(format!(
                    "Block range {} exceeds maximum of {}",
                    range, self.config.max_logs_block_range
                ))
                .into());
            }
        }

        self.storage
            .get_logs(filter)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn send_raw_transaction(&self, tx_bytes: Bytes) -> JsonRpcResult<B256> {
        debug!("eth_sendRawTransaction: {} bytes", tx_bytes.len());

        // Validate the transaction before submission
        let (tx, sender) = self.validate_transaction(&tx_bytes).map_err(|e| {
            warn!("Transaction validation failed: {}", e);
            Self::to_json_rpc_error(e)
        })?;

        trace!(
            "Submitting transaction to mempool: hash={}, sender={}",
            tx.tx_hash(),
            sender
        );

        self.mempool
            .submit_transaction(tx_bytes)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn call(&self, call_request: CallRequest, block: Option<String>) -> JsonRpcResult<Bytes> {
        trace!("eth_call: {:?}, block={:?}", call_request, block);
        let block_num = self.parse_block_number(block)?;
        self.executor
            .call(
                call_request.from,
                call_request.to,
                call_request.gas.map(|g| g.to::<u64>()),
                call_request.gas_price,
                call_request.value,
                call_request.data,
                block_num,
            )
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn estimate_gas(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<U64> {
        trace!("eth_estimateGas: {:?}, block={:?}", call_request, block);
        let block_num = self.parse_block_number(block)?;
        let gas = self
            .executor
            .estimate_gas(
                call_request.from,
                call_request.to,
                call_request.gas.map(|g| g.to::<u64>()),
                call_request.gas_price,
                call_request.value,
                call_request.data,
                block_num,
            )
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(gas))
    }

    async fn gas_price(&self) -> JsonRpcResult<U256> {
        trace!("eth_gasPrice");
        // For now, return a fixed gas price of 1 gwei
        // TODO: Implement dynamic gas price estimation
        Ok(U256::from(1_000_000_000u64))
    }

    async fn fee_history(
        &self,
        block_count: U64,
        newest_block: String,
        reward_percentiles: Option<Vec<f64>>,
    ) -> JsonRpcResult<FeeHistory> {
        debug!(
            "eth_feeHistory: block_count={}, newest_block={}, percentiles={:?}",
            block_count, newest_block, reward_percentiles
        );

        let block_count = block_count.to::<u64>();

        // Validate block count (max 1024 per Ethereum spec)
        const MAX_BLOCK_COUNT: u64 = 1024;
        if block_count > MAX_BLOCK_COUNT {
            return Err(RpcError::InvalidParams(format!(
                "Block count {} exceeds maximum of {}",
                block_count, MAX_BLOCK_COUNT
            ))
            .into());
        }

        if block_count == 0 {
            return Ok(FeeHistory::default());
        }

        // Validate reward percentiles
        if let Some(ref percentiles) = reward_percentiles {
            for p in percentiles {
                if !p.is_finite() || *p < 0.0 || *p > 100.0 {
                    return Err(RpcError::InvalidParams(format!(
                        "Invalid percentile value: {}. Must be between 0 and 100",
                        p
                    ))
                    .into());
                }
            }
            // Check percentiles are monotonically increasing
            for i in 1..percentiles.len() {
                if percentiles[i] < percentiles[i - 1] {
                    return Err(RpcError::InvalidParams(
                        "Reward percentiles must be monotonically increasing".to_string(),
                    )
                    .into());
                }
            }
        }

        // Parse the newest block
        let newest_block_tag = self.parse_block_number(Some(newest_block))?;
        let newest_block_number = match newest_block_tag {
            BlockNumberOrTag::Latest
            | BlockNumberOrTag::Safe
            | BlockNumberOrTag::Finalized
            | BlockNumberOrTag::Pending => self
                .storage
                .latest_block_number()
                .await
                .map_err(Self::to_json_rpc_error)?,
            BlockNumberOrTag::Earliest => 0,
            BlockNumberOrTag::Number(n) => n,
        };

        // Calculate the block range
        let oldest_block = newest_block_number.saturating_sub(block_count - 1);
        let actual_block_count = newest_block_number - oldest_block + 1;

        // Collect fee history data
        let mut base_fee_per_gas: Vec<u128> = Vec::with_capacity((actual_block_count + 1) as usize);
        let mut gas_used_ratio: Vec<f64> = Vec::with_capacity(actual_block_count as usize);
        let mut reward: Option<Vec<Vec<u128>>> = if reward_percentiles.is_some() {
            Some(Vec::with_capacity(actual_block_count as usize))
        } else {
            None
        };

        for block_num in oldest_block..=newest_block_number {
            // Get block data
            let block = self
                .storage
                .get_block_by_number(BlockNumberOrTag::Number(block_num), false)
                .await
                .map_err(Self::to_json_rpc_error)?;

            match block {
                Some(block) => {
                    // Get base fee (0 for pre-EIP-1559 blocks)
                    let base_fee = block.header.base_fee_per_gas.unwrap_or(0) as u128;
                    base_fee_per_gas.push(base_fee);

                    // Calculate gas used ratio
                    let gas_limit = block.header.gas_limit;
                    let gas_used = block.header.gas_used;
                    let ratio = if gas_limit > 0 {
                        gas_used as f64 / gas_limit as f64
                    } else {
                        0.0
                    };
                    gas_used_ratio.push(ratio);

                    // Calculate reward percentiles if requested
                    if let Some(ref percentiles) = reward_percentiles {
                        // For simplicity, return zeros for now
                        // A full implementation would need transaction priority fees
                        let block_rewards: Vec<u128> = percentiles.iter().map(|_| 0u128).collect();
                        if let Some(ref mut rewards) = reward {
                            rewards.push(block_rewards);
                        }
                    }
                }
                None => {
                    // Block not found, use defaults
                    base_fee_per_gas.push(0);
                    gas_used_ratio.push(0.0);
                    if let Some(ref mut rewards) = reward {
                        let percentile_count = reward_percentiles.as_ref().map(|p| p.len()).unwrap_or(0);
                        rewards.push(vec![0u128; percentile_count]);
                    }
                }
            }
        }

        // Add the next block's base fee estimate (simple calculation)
        // In reality, this would use the EIP-1559 base fee adjustment formula
        let last_base_fee = base_fee_per_gas.last().copied().unwrap_or(0);
        let last_ratio = gas_used_ratio.last().copied().unwrap_or(0.5);

        // Simple base fee estimation: increase if block was >50% full, decrease otherwise
        let next_base_fee = if last_ratio > 0.5 {
            // Block was more than 50% full, increase base fee
            let increase = (last_base_fee as f64 * 0.125 * (last_ratio - 0.5) * 2.0) as u128;
            last_base_fee.saturating_add(increase)
        } else {
            // Block was less than 50% full, decrease base fee
            let decrease = (last_base_fee as f64 * 0.125 * (0.5 - last_ratio) * 2.0) as u128;
            last_base_fee.saturating_sub(decrease)
        };
        base_fee_per_gas.push(next_base_fee);

        Ok(FeeHistory {
            oldest_block,
            base_fee_per_gas,
            gas_used_ratio,
            base_fee_per_blob_gas: Vec::new(), // Not supporting blob transactions yet
            blob_gas_used_ratio: Vec::new(),
            reward,
        })
    }

    async fn pending_transactions(&self) -> JsonRpcResult<Vec<Transaction>> {
        trace!("eth_pendingTransactions");

        // Get pending transactions from mempool
        let pending_by_sender = self
            .mempool
            .get_pending_content()
            .await
            .map_err(Self::to_json_rpc_error)?;

        // Flatten into a single list
        let mut transactions: Vec<Transaction> = Vec::new();
        for (_sender, txs) in pending_by_sender {
            transactions.extend(txs);
        }

        debug!(
            "eth_pendingTransactions: returning {} transactions",
            transactions.len()
        );
        Ok(transactions)
    }

    async fn get_uncle_by_block_hash_and_index(
        &self,
        block_hash: B256,
        index: U64,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getUncleByBlockHashAndIndex: hash={}, index={}",
            block_hash,
            index
        );
        // CipherBFT is a PoS chain - no uncles exist
        Ok(None)
    }

    async fn get_uncle_by_block_number_and_index(
        &self,
        block: String,
        index: U64,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getUncleByBlockNumberAndIndex: block={}, index={}",
            block,
            index
        );
        // CipherBFT is a PoS chain - no uncles exist
        Ok(None)
    }

    async fn get_uncle_count_by_block_hash(&self, block_hash: B256) -> JsonRpcResult<U64> {
        trace!("eth_getUncleCountByBlockHash: hash={}", block_hash);
        // CipherBFT is a PoS chain - no uncles exist
        Ok(U64::ZERO)
    }

    async fn get_uncle_count_by_block_number(&self, block: String) -> JsonRpcResult<U64> {
        trace!("eth_getUncleCountByBlockNumber: block={}", block);
        // CipherBFT is a PoS chain - no uncles exist
        Ok(U64::ZERO)
    }

    async fn get_proof(
        &self,
        address: Address,
        storage_keys: Vec<B256>,
        block: Option<String>,
    ) -> JsonRpcResult<EIP1186AccountProofResponse> {
        trace!(
            "eth_getProof: address={}, keys={:?}, block={:?}",
            address,
            storage_keys.len(),
            block
        );

        // eth_getProof requires direct access to the state trie for Merkle proof generation.
        // CipherBFT does not currently expose state trie access, so this method is unsupported.
        // Many L2s and BFT chains similarly don't support this method.
        Err(ErrorObjectOwned::owned(
            -32601,
            "eth_getProof is not supported by this node".to_string(),
            None::<()>,
        ))
    }

    async fn create_access_list(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<AccessListResult> {
        trace!(
            "eth_createAccessList: to={:?}, block={:?}",
            call_request.to,
            block
        );

        // eth_createAccessList requires simulating the transaction and tracking
        // all state accesses. CipherBFT does not currently expose state access
        // tracking, so this method is unsupported.
        Err(ErrorObjectOwned::owned(
            -32601,
            "eth_createAccessList is not supported by this node".to_string(),
            None::<()>,
        ))
    }
}
