//! Ethereum namespace RPC API implementation.

use std::sync::Arc;

use alloy_primitives::{Address, Bytes, B256, U256, U64};
use alloy_rpc_types_eth::{Block, Filter, Log, SyncInfo, SyncStatus as EthSyncStatus, Transaction, TransactionReceipt};
use jsonrpsee::core::RpcResult as JsonRpcResult;
use jsonrpsee::proc_macros::rpc;
use jsonrpsee::types::ErrorObjectOwned;
use tracing::{debug, trace};

use crate::config::RpcConfig;
use crate::error::RpcError;
use crate::traits::{BlockNumberOrTag, ExecutionApi, MempoolApi, RpcStorage, SyncStatus};

/// Ethereum namespace RPC trait.
///
/// This trait is auto-generated by jsonrpsee and provides both server and client
/// implementations for the eth_* RPC methods.
#[rpc(server, namespace = "eth")]
pub trait EthRpc {
    /// Returns the chain ID used for signing replay-protected transactions.
    #[method(name = "chainId")]
    async fn chain_id(&self) -> JsonRpcResult<U64>;

    /// Returns the number of most recent block.
    #[method(name = "blockNumber")]
    async fn block_number(&self) -> JsonRpcResult<U64>;

    /// Returns an object with data about the sync status or false if not syncing.
    #[method(name = "syncing")]
    async fn syncing(&self) -> JsonRpcResult<EthSyncStatus>;

    /// Returns the balance of the account at the given address.
    #[method(name = "getBalance")]
    async fn get_balance(&self, address: Address, block: Option<String>) -> JsonRpcResult<U256>;

    /// Returns code at a given address.
    #[method(name = "getCode")]
    async fn get_code(&self, address: Address, block: Option<String>) -> JsonRpcResult<Bytes>;

    /// Returns the value from a storage position at a given address.
    #[method(name = "getStorageAt")]
    async fn get_storage_at(
        &self,
        address: Address,
        slot: U256,
        block: Option<String>,
    ) -> JsonRpcResult<B256>;

    /// Returns the number of transactions sent from an address.
    #[method(name = "getTransactionCount")]
    async fn get_transaction_count(&self, address: Address, block: Option<String>) -> JsonRpcResult<U64>;

    /// Returns information about a block by hash.
    #[method(name = "getBlockByHash")]
    async fn get_block_by_hash(
        &self,
        hash: B256,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns information about a block by number.
    #[method(name = "getBlockByNumber")]
    async fn get_block_by_number(
        &self,
        block: String,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>>;

    /// Returns the information about a transaction by transaction hash.
    #[method(name = "getTransactionByHash")]
    async fn get_transaction_by_hash(&self, hash: B256) -> JsonRpcResult<Option<Transaction>>;

    /// Returns the receipt of a transaction by transaction hash.
    #[method(name = "getTransactionReceipt")]
    async fn get_transaction_receipt(&self, hash: B256) -> JsonRpcResult<Option<TransactionReceipt>>;

    /// Returns an array of all logs matching a given filter object.
    #[method(name = "getLogs")]
    async fn get_logs(&self, filter: Filter) -> JsonRpcResult<Vec<Log>>;

    /// Submits a raw transaction.
    #[method(name = "sendRawTransaction")]
    async fn send_raw_transaction(&self, tx_bytes: Bytes) -> JsonRpcResult<B256>;

    /// Executes a new message call immediately without creating a transaction.
    #[method(name = "call")]
    async fn call(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<Bytes>;

    /// Generates and returns an estimate of how much gas is necessary.
    #[method(name = "estimateGas")]
    async fn estimate_gas(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<U64>;

    /// Returns the current gas price in wei.
    #[method(name = "gasPrice")]
    async fn gas_price(&self) -> JsonRpcResult<U256>;
}

/// Call request parameters for eth_call and eth_estimateGas.
#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct CallRequest {
    /// Sender address.
    pub from: Option<Address>,
    /// Recipient address.
    pub to: Option<Address>,
    /// Gas limit.
    pub gas: Option<U64>,
    /// Gas price.
    pub gas_price: Option<U256>,
    /// Max fee per gas (EIP-1559).
    pub max_fee_per_gas: Option<U256>,
    /// Max priority fee per gas (EIP-1559).
    pub max_priority_fee_per_gas: Option<U256>,
    /// Value to send.
    pub value: Option<U256>,
    /// Transaction data.
    #[serde(alias = "input")]
    pub data: Option<Bytes>,
}

/// Ethereum namespace RPC handler.
pub struct EthApi<S, M, E>
where
    S: RpcStorage,
    M: MempoolApi,
    E: ExecutionApi,
{
    /// Storage interface.
    storage: Arc<S>,
    /// Mempool interface.
    mempool: Arc<M>,
    /// Execution interface.
    executor: Arc<E>,
    /// RPC configuration.
    config: Arc<RpcConfig>,
}

impl<S, M, E> EthApi<S, M, E>
where
    S: RpcStorage,
    M: MempoolApi,
    E: ExecutionApi,
{
    /// Create a new EthApi instance.
    pub fn new(storage: Arc<S>, mempool: Arc<M>, executor: Arc<E>, config: Arc<RpcConfig>) -> Self {
        Self {
            storage,
            mempool,
            executor,
            config,
        }
    }

    /// Parse a block number or tag from a string.
    fn parse_block_number(&self, block: Option<String>) -> Result<BlockNumberOrTag, ErrorObjectOwned> {
        match block.as_deref() {
            None | Some("latest") => Ok(BlockNumberOrTag::Latest),
            Some("earliest") => Ok(BlockNumberOrTag::Earliest),
            Some("pending") => Ok(BlockNumberOrTag::Pending),
            Some("safe") => Ok(BlockNumberOrTag::Safe),
            Some("finalized") => Ok(BlockNumberOrTag::Finalized),
            Some(s) => {
                // Parse hex number (0x prefix) or decimal
                let num = if let Some(hex_str) = s.strip_prefix("0x") {
                    u64::from_str_radix(hex_str, 16)
                        .map_err(|_| RpcError::InvalidParams(format!("Invalid block number: {}", s)))?
                } else {
                    s.parse::<u64>()
                        .map_err(|_| RpcError::InvalidParams(format!("Invalid block number: {}", s)))?
                };
                Ok(BlockNumberOrTag::Number(num))
            }
        }
    }

    /// Convert internal RpcError to jsonrpsee ErrorObjectOwned.
    fn to_json_rpc_error(err: RpcError) -> ErrorObjectOwned {
        err.into()
    }
}

#[async_trait::async_trait]
impl<S, M, E> EthRpcServer for EthApi<S, M, E>
where
    S: RpcStorage + 'static,
    M: MempoolApi + 'static,
    E: ExecutionApi + 'static,
{
    async fn chain_id(&self) -> JsonRpcResult<U64> {
        trace!("eth_chainId");
        Ok(U64::from(self.config.chain_id))
    }

    async fn block_number(&self) -> JsonRpcResult<U64> {
        trace!("eth_blockNumber");
        let number = self
            .storage
            .latest_block_number()
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(number))
    }

    async fn syncing(&self) -> JsonRpcResult<EthSyncStatus> {
        trace!("eth_syncing");
        let status = self
            .storage
            .sync_status()
            .await
            .map_err(Self::to_json_rpc_error)?;

        match status {
            SyncStatus::NotSyncing => Ok(EthSyncStatus::None),
            SyncStatus::Syncing {
                starting_block,
                current_block,
                highest_block,
            } => Ok(EthSyncStatus::Info(Box::new(SyncInfo {
                starting_block: U256::from(starting_block),
                current_block: U256::from(current_block),
                highest_block: U256::from(highest_block),
                // Optional fields
                warp_chunks_amount: None,
                warp_chunks_processed: None,
                stages: None,
            }))),
        }
    }

    async fn get_balance(&self, address: Address, block: Option<String>) -> JsonRpcResult<U256> {
        trace!("eth_getBalance: address={}, block={:?}", address, block);
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_balance(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_code(&self, address: Address, block: Option<String>) -> JsonRpcResult<Bytes> {
        trace!("eth_getCode: address={}, block={:?}", address, block);
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_code(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_storage_at(
        &self,
        address: Address,
        slot: U256,
        block: Option<String>,
    ) -> JsonRpcResult<B256> {
        trace!(
            "eth_getStorageAt: address={}, slot={}, block={:?}",
            address,
            slot,
            block
        );
        let block_num = self.parse_block_number(block)?;
        self.storage
            .get_storage_at(address, slot, block_num)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_count(&self, address: Address, block: Option<String>) -> JsonRpcResult<U64> {
        trace!(
            "eth_getTransactionCount: address={}, block={:?}",
            address,
            block
        );
        let block_num = self.parse_block_number(block)?;
        let count = self
            .storage
            .get_transaction_count(address, block_num)
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(count))
    }

    async fn get_block_by_hash(
        &self,
        hash: B256,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getBlockByHash: hash={}, full_txs={}",
            hash,
            full_transactions
        );
        self.storage
            .get_block_by_hash(hash, full_transactions)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_block_by_number(
        &self,
        block: String,
        full_transactions: bool,
    ) -> JsonRpcResult<Option<Block>> {
        trace!(
            "eth_getBlockByNumber: block={}, full_txs={}",
            block,
            full_transactions
        );
        let block_num = self.parse_block_number(Some(block))?;
        self.storage
            .get_block_by_number(block_num, full_transactions)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_by_hash(&self, hash: B256) -> JsonRpcResult<Option<Transaction>> {
        trace!("eth_getTransactionByHash: hash={}", hash);
        self.storage
            .get_transaction_by_hash(hash)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_transaction_receipt(&self, hash: B256) -> JsonRpcResult<Option<TransactionReceipt>> {
        trace!("eth_getTransactionReceipt: hash={}", hash);
        self.storage
            .get_transaction_receipt(hash)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn get_logs(&self, filter: Filter) -> JsonRpcResult<Vec<Log>> {
        debug!("eth_getLogs: filter={:?}", filter);

        // Validate block range doesn't exceed max
        if let (Some(from_num), Some(to_num)) = (
            filter.block_option.get_from_block().and_then(|b| b.as_number()),
            filter.block_option.get_to_block().and_then(|b| b.as_number()),
        ) {
            let range = to_num.saturating_sub(from_num);
            if range > self.config.max_logs_block_range {
                return Err(RpcError::InvalidParams(format!(
                    "Block range {} exceeds maximum of {}",
                    range, self.config.max_logs_block_range
                ))
                .into());
            }
        }

        self.storage
            .get_logs(filter)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn send_raw_transaction(&self, tx_bytes: Bytes) -> JsonRpcResult<B256> {
        debug!("eth_sendRawTransaction: {} bytes", tx_bytes.len());
        self.mempool
            .submit_transaction(tx_bytes)
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn call(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<Bytes> {
        trace!("eth_call: {:?}, block={:?}", call_request, block);
        let block_num = self.parse_block_number(block)?;
        self.executor
            .call(
                call_request.from,
                call_request.to,
                call_request.gas.map(|g| g.to::<u64>()),
                call_request.gas_price,
                call_request.value,
                call_request.data,
                block_num,
            )
            .await
            .map_err(Self::to_json_rpc_error)
    }

    async fn estimate_gas(
        &self,
        call_request: CallRequest,
        block: Option<String>,
    ) -> JsonRpcResult<U64> {
        trace!("eth_estimateGas: {:?}, block={:?}", call_request, block);
        let block_num = self.parse_block_number(block)?;
        let gas = self
            .executor
            .estimate_gas(
                call_request.from,
                call_request.to,
                call_request.gas.map(|g| g.to::<u64>()),
                call_request.gas_price,
                call_request.value,
                call_request.data,
                block_num,
            )
            .await
            .map_err(Self::to_json_rpc_error)?;
        Ok(U64::from(gas))
    }

    async fn gas_price(&self) -> JsonRpcResult<U256> {
        trace!("eth_gasPrice");
        // For now, return a fixed gas price of 1 gwei
        // TODO: Implement dynamic gas price estimation
        Ok(U256::from(1_000_000_000u64))
    }
}
